$ARGUMENTSの要求タスクを実行してください

# 基本ルール

- 作業時は必ずタスクファイルを`project/tasks/backlog`に作成
- `project/template/DEVELOPMENT_TASK.md`沿ったタスク記述
- タスクファイルの命名規則は`[auto increment]-[task-name]-development.md`(`02-calculator-multiply-development.md`)
- 要件定義書の作成(`project/requirements/*.md`)

# 適応型タスクオーケストレーター

## タスク

### ステップ1: 初期複雑性分析

まず、タスクの複雑性を評価します：
- キーワード分析（「分析」「統合」「複数」等の存在）
- 依存関係の検出（「してから」「の後に」等）
- 並列実行可能性の評価
- 推定作業量の算出

複雑性スコア: [1-10で自動判定]

### ステップ2: 動的実行計画の生成

複雑性に基づいて実行戦略を決定：

**低複雑性（1-3）の場合:**
- 2ステップ構成：分析→実行
- 各ステップ1-2並列タスク
- 最小限のコンテキスト共有

**中複雑性（4-6）の場合:**
- 3ステップ構成：分析→実行→検証
- 各ステップ2-3並列タスク
- 段階的な結果集約

**高複雑性（7-10）の場合:**
- 4-5ステップ構成：詳細分析→準備→段階実行→統合→検証
- 各ステップ3-5並列タスク
- 適応的な計画修正を含む

### ステップ3: 実行と適応

各ステップ実行後に自動的に：
1. 結果を100-200語で要約
2. 予期せぬ発見や問題を識別
3. 残りの計画を必要に応じて調整

**適応ルール:**
- エラー発見時→修正ステップを挿入
- 想定より単純→後続ステップを簡略化
- 新たな複雑性→調査ステップを追加
- 依存関係変更→実行順序を再編成

### ステップ4: プログレッシブ実行

各ステップで：
- 並列タスクを同時実行
- 結果を200語以内で要約
- 次ステップへの影響を評価
- 必要に応じて残りの計画を調整
- 最小限の必須情報のみを次へ伝達

### ステップ5: 最終統合

全ステップ完了後：
- 各ステップの成果を統合
- 全体的な成功/失敗の評価
- 学習事項の抽出

## 実行開始

それでは、入力されたタスクに対してこのフレームワークを適用します：

[ここから実際のタスク分析と実行計画の生成を開始]